using EFCore.DomainModelGenerator.Steps;
using Microsoft.CodeAnalysis;

namespace EFCore.DomainModelGenerator.Emissions;

internal static class ModelEmission
{
  public static void Emit(SourceProductionContext context, IEnumerable<MetadataGroup> groups)
  {
    foreach (var group in groups)
    {
      context.AddSource(group.GetFileName(), group.GenerateCode());
    }
  }
}

file static class Impl
{
  extension(MetadataGroup group)
  {
    public string GetFileName() => $"{group.Model.ModelName}.g.cs";

    public string GenerateCode()
    {
      // TODO: Refactor to support multiple DbContexts.
      // The current logic assumes a single context and will throw an exception if more than one is provided.
      var firstContext = group.Contexts.SingleOrDefault() ?? throw new ModelEmissionException("firstContext");
      var model = group.Model;
      var sets = group.Sets.ToArray();

      var contextParameters = new Parameter[] { new(firstContext.ContextType.ToString(), "Db") };
      var dependencyParameters = model.Dependencies.Select(static x => new Parameter(x.DependsOn, x.MappedName));
      var parameters = contextParameters.Concat(dependencyParameters).ToArray();

      return
        $$"""
          // <auto-generated/>

          namespace {{group.Config.DomainNamespace}};
          using global::Microsoft.EntityFrameworkCore;
          using global::System.Linq;

          public partial class {{model.ModelName}}({{parameters.GetConstructorExpr()}})
          {
          {{parameters.GetPropertiesExpr()}}

          {{string.Join("\n", sets.Select(static x => SinglePropertyLine(x, writable: false)))}}
          }

          public partial class Writable{{model.ModelName}}({{parameters.GetConstructorExpr()}}) 
          : {{model.ModelName}}({{parameters.GetArgumentsExpr()}})
          {
          {{string.Join("\n", sets.Select(static x => SinglePropertyLine(x, writable: true)))}}
          }
          """;
    }

    private static string SinglePropertyLine(SetMetadata set, bool writable)
    {
      var accessibility = writable ? set.WritableAccessibility : set.ReadonlyAccessibility;
      var newKeyword = writable ? "new" : "";
      var collectionType = writable ? "DbSet" : "IQueryable";
      var elementType = set.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
      return $"{accessibility} {newKeyword} {collectionType}<{elementType}> {set.MappedName} => Db.{set.OriginalName};";
    }
  }
}

file record struct Parameter(string Type, string Name)
{
  public string MaskedName => $"_{Name}";
}

file static class ParameterExprHelper
{
  extension(IEnumerable<Parameter> parameters)
  {
    public string GetConstructorExpr()
    {
      var segments = parameters.Select(x => $"{x.Type} {x.MaskedName}");
      return string.Join(", ", segments);
    }

    public string GetArgumentsExpr()
    {
      var segments = parameters.Select(x => x.MaskedName);
      return string.Join(", ", segments);
    }

    public string GetPropertiesExpr()
    {
      var segments = parameters.Select(x => $"protected {x.Type} {x.Name} => {x.MaskedName};");
      return string.Join("\n", segments);
    }
  }
}

internal class ModelEmissionException(string segment) : InvalidOperationException(segment);
